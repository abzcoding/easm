#[cfg(test)]
mod vulnerability_integration_tests {
    use backend::models::{Asset, Organization, Port, Vulnerability};
    use chrono::Utc;
    use infrastructure::repositories::RepositoryFactory;
    use serde_json::json;
    use shared::{
        config::Config,
        types::{AssetType, PortStatus, Protocol, Severity, VulnerabilityStatus},
    };
    use uuid::Uuid;

    async fn setup_test_db() -> RepositoryFactory {
        let _ = dotenvy::dotenv();
        let config = Config::from_env().expect("Failed to load config");
        let database_url = config.database_url.clone();

        let pool = sqlx::PgPool::connect(&database_url)
            .await
            .expect("Failed to connect to database");

        RepositoryFactory::new(pool)
    }

    async fn setup_test_organization() -> (RepositoryFactory, Organization) {
        let factory = setup_test_db().await;
        let org_repo = factory.organization_repository();

        // Create a test organization
        let org_name = format!("Vuln Test Org {}", Uuid::new_v4());
        let org = Organization::new(org_name);
        let org = org_repo
            .create_organization(&org)
            .await
            .expect("Failed to create organization");

        (factory, org)
    }

    #[tokio::test]
    async fn test_vulnerability_lifecycle() {
        let (factory, org) = setup_test_organization().await;

        // Create repositories
        let asset_repo = factory.asset_repository();
        let port_repo = factory.port_repository();
        let vuln_repo = factory.vulnerability_repository();

        // Create web app asset
        let web_asset = Asset::new(
            org.id,
            AssetType::WebApp,
            "https://vulntest.example.com".to_string(),
            None,
        );
        let web_asset = asset_repo
            .create_asset(&web_asset)
            .await
            .expect("Failed to create web asset");

        // Create a vulnerability for the web app
        let vuln1 = Vulnerability::new(
            web_asset.id,
            None, // No port association
            "Cross-Site Scripting (XSS)".to_string(),
            Some("Reflected XSS in search parameter".to_string()),
            Severity::High,
            Some("CVE-2023-12345".to_string()),
            Some(json!({
                "url": "https://vulntest.example.com/search?q=<script>alert(1)</script>",
                "parameter": "q",
                "payload": "<script>alert(1)</script>"
            })),
            Some("Implement proper input sanitization and CSP headers".to_string()),
        );

        let created_vuln1 = vuln_repo
            .create_vulnerability(&vuln1)
            .await
            .expect("Failed to create XSS vulnerability");

        assert_eq!(created_vuln1.severity, Severity::High);
        assert_eq!(created_vuln1.status, VulnerabilityStatus::Open);

        // Create IP address asset related to the web app
        let ip_asset = Asset::new(
            org.id,
            AssetType::IPAddress,
            "192.168.1.5".to_string(),
            None,
        );
        let ip_asset = asset_repo
            .create_asset(&ip_asset)
            .await
            .expect("Failed to create IP asset");

        // Create a port on the IP
        let port = Port {
            id: Uuid::new_v4(),
            asset_id: ip_asset.id,
            port_number: 22,
            protocol: Protocol::TCP,
            service_name: Some("ssh".to_string()),
            banner: Some("OpenSSH_7.6p1".to_string()),
            status: PortStatus::Open,
            first_seen: Utc::now(),
            last_seen: Utc::now(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        let ssh_port = port_repo
            .create_port(&port)
            .await
            .expect("Failed to create SSH port");

        // Create a vulnerability for the SSH port
        let vuln2 = Vulnerability::new(
            ip_asset.id,
            Some(ssh_port.id),
            "OpenSSH Weak Cryptographic Policy".to_string(),
            Some("SSH server allows weak cryptographic algorithms".to_string()),
            Severity::Medium,
            None, // No CVE
            Some(json!({
                "affected_algorithms": ["diffie-hellman-group1-sha1", "ssh-dss"],
                "scan_timestamp": Utc::now().to_rfc3339()
            })),
            Some("Update SSH configuration to disable weak algorithms".to_string()),
        );

        let created_vuln2 = vuln_repo
            .create_vulnerability(&vuln2)
            .await
            .expect("Failed to create SSH vulnerability");

        assert_eq!(created_vuln2.severity, Severity::Medium);
        assert_eq!(created_vuln2.port_id, Some(ssh_port.id));

        // Test vulnerability retrieval by asset
        let web_vulns = vuln_repo
            .list_vulnerabilities(Some(web_asset.id), None, None, None, 10, 0)
            .await
            .expect("Failed to get vulnerabilities by web asset");

        assert_eq!(web_vulns.len(), 1);
        assert_eq!(web_vulns[0].title, "Cross-Site Scripting (XSS)");

        let ip_vulns = vuln_repo
            .list_vulnerabilities(Some(ip_asset.id), None, None, None, 10, 0)
            .await
            .expect("Failed to get vulnerabilities by IP asset");

        assert_eq!(ip_vulns.len(), 1);
        assert_eq!(ip_vulns[0].title, "OpenSSH Weak Cryptographic Policy");

        // Test vulnerability retrieval by port
        let port_vulns = vuln_repo
            .list_vulnerabilities(None, Some(ssh_port.id), None, None, 10, 0)
            .await
            .expect("Failed to get vulnerabilities by port");

        assert_eq!(port_vulns.len(), 1);
        assert_eq!(port_vulns[0].id, created_vuln2.id);

        // Test vulnerability retrieval by severity
        let high_vulns = vuln_repo
            .list_vulnerabilities(None, None, Some(Severity::High), None, 10, 0)
            .await
            .expect("Failed to get high severity vulnerabilities");

        assert!(high_vulns.iter().any(|v| v.id == created_vuln1.id));

        // Test vulnerability update (status change)
        let mut updated_vuln = created_vuln1.clone();
        updated_vuln.status = VulnerabilityStatus::AcceptedRisk;

        let updated_result = vuln_repo
            .update_vulnerability(&updated_vuln)
            .await
            .expect("Failed to update vulnerability status");

        assert_eq!(updated_result.status, VulnerabilityStatus::AcceptedRisk);

        // Test vulnerability remediation (closing)
        let mut fixed_vuln = updated_result.clone();
        fixed_vuln.status = VulnerabilityStatus::Closed;
        fixed_vuln.resolved_at = Some(Utc::now());

        let fixed_result = vuln_repo
            .update_vulnerability(&fixed_vuln)
            .await
            .expect("Failed to resolve vulnerability");

        assert_eq!(fixed_result.status, VulnerabilityStatus::Closed);
        assert!(fixed_result.resolved_at.is_some());

        // Clean up
        let _ = vuln_repo
            .delete_vulnerability(created_vuln1.id)
            .await
            .expect("Failed to delete vulnerability 1");

        let _ = vuln_repo
            .delete_vulnerability(created_vuln2.id)
            .await
            .expect("Failed to delete vulnerability 2");

        let _ = port_repo
            .delete_port(ssh_port.id)
            .await
            .expect("Failed to delete port");

        let _ = asset_repo
            .delete_asset(web_asset.id)
            .await
            .expect("Failed to delete web asset");

        let _ = asset_repo
            .delete_asset(ip_asset.id)
            .await
            .expect("Failed to delete IP asset");

        let _ = factory
            .organization_repository()
            .delete_organization(org.id)
            .await
            .expect("Failed to delete organization");
    }

    #[tokio::test]
    async fn test_vulnerability_aggregation_and_correlation() {
        let (factory, org) = setup_test_organization().await;

        // Create repositories
        let asset_repo = factory.asset_repository();
        let vuln_repo = factory.vulnerability_repository();

        // Clean up any potential stale data from previous test runs
        // First, get all expired cert vulnerabilities
        let stale_vulns = vuln_repo
            .list_vulnerabilities(None, None, None, None, 1000, 0)
            .await
            .expect("Failed to get vulnerabilities");

        // Delete any vulnerabilities with title "Expired TLS Certificate"
        for vuln in stale_vulns {
            if vuln.title == "Expired TLS Certificate"
                || vuln.title == "API Key Exposure"
                || vuln.title == "Default Admin Credentials"
            {
                let _ = vuln_repo
                    .delete_vulnerability(vuln.id)
                    .await
                    .expect("Failed to delete stale vulnerability");
            }
        }

        // Create multiple related assets
        let domain = format!("vuln-{}.example.com", Uuid::new_v4().as_simple());

        // Parent domain
        let domain_asset = Asset::new(org.id, AssetType::Domain, domain.clone(), None);
        let domain_asset = asset_repo
            .create_asset(&domain_asset)
            .await
            .expect("Failed to create domain asset");

        // Subdomain 1
        let subdomain1 = format!("api.{}", domain);
        let subdomain1_asset = Asset::new(org.id, AssetType::Domain, subdomain1.clone(), None);
        let subdomain1_asset = asset_repo
            .create_asset(&subdomain1_asset)
            .await
            .expect("Failed to create subdomain1 asset");

        // Subdomain 2
        let subdomain2 = format!("admin.{}", domain);
        let subdomain2_asset = Asset::new(org.id, AssetType::Domain, subdomain2.clone(), None);
        let subdomain2_asset = asset_repo
            .create_asset(&subdomain2_asset)
            .await
            .expect("Failed to create subdomain2 asset");

        // Web applications for each
        let web_app1 = Asset::new(
            org.id,
            AssetType::WebApp,
            format!("https://{}", subdomain1),
            Some(json!({ "domain": subdomain1 })),
        );
        let web_app1_asset = asset_repo
            .create_asset(&web_app1)
            .await
            .expect("Failed to create web app1 asset");

        let web_app2 = Asset::new(
            org.id,
            AssetType::WebApp,
            format!("https://{}", subdomain2),
            Some(json!({ "domain": subdomain2 })),
        );
        let web_app2_asset = asset_repo
            .create_asset(&web_app2)
            .await
            .expect("Failed to create web app2 asset");

        // Create similar vulnerabilities across assets

        // 1. TLS certificate issues on both subdomains
        let vuln1 = Vulnerability::new(
            subdomain1_asset.id,
            None,
            "Expired TLS Certificate".to_string(),
            Some("The TLS certificate has expired".to_string()),
            Severity::Medium,
            None,
            Some(json!({
                "expires": "2023-01-01T00:00:00Z",
                "current_date": "2023-02-01T00:00:00Z"
            })),
            Some("Renew the SSL/TLS certificate".to_string()),
        );

        let vuln1_created = vuln_repo
            .create_vulnerability(&vuln1)
            .await
            .expect("Failed to create vulnerability 1");

        let vuln2 = Vulnerability::new(
            subdomain2_asset.id,
            None,
            "Expired TLS Certificate".to_string(),
            Some("The TLS certificate has expired".to_string()),
            Severity::Medium,
            None,
            Some(json!({
                "expires": "2023-01-01T00:00:00Z",
                "current_date": "2023-02-01T00:00:00Z"
            })),
            Some("Renew the SSL/TLS certificate".to_string()),
        );

        let vuln2_created = vuln_repo
            .create_vulnerability(&vuln2)
            .await
            .expect("Failed to create vulnerability 2");

        // 2. Different vulnerabilities on web apps
        let vuln3 = Vulnerability::new(
            web_app1_asset.id,
            None,
            "API Key Exposure".to_string(),
            Some("API key is exposed in JavaScript source".to_string()),
            Severity::Critical,
            None,
            Some(json!({
                "key_type": "API_KEY",
                "location": "script.js"
            })),
            Some(
                "Remove API key from client-side code and implement server-side authentication"
                    .to_string(),
            ),
        );

        let vuln3_created = vuln_repo
            .create_vulnerability(&vuln3)
            .await
            .expect("Failed to create vulnerability 3");

        let vuln4 = Vulnerability::new(
            web_app2_asset.id,
            None,
            "Default Admin Credentials".to_string(),
            Some("Admin interface uses default credentials".to_string()),
            Severity::Critical,
            None,
            Some(json!({
                "username": "admin",
                "default_password": true
            })),
            Some("Change default admin password and enforce strong password policy".to_string()),
        );

        let vuln4_created = vuln_repo
            .create_vulnerability(&vuln4)
            .await
            .expect("Failed to create vulnerability 4");

        // Test vulnerability retrieval by organization
        // Since we don't have get_vulnerabilities_by_organization,
        // we'll list all vulnerabilities (limit high) and filter for this org
        let all_vulns = vuln_repo
            .list_vulnerabilities(None, None, None, None, 100, 0)
            .await
            .expect("Failed to get all vulnerabilities");

        // Filter for org's assets
        let org_asset_ids = [
            domain_asset.id,
            subdomain1_asset.id,
            subdomain2_asset.id,
            web_app1_asset.id,
            web_app2_asset.id,
        ];
        let org_vulns: Vec<_> = all_vulns
            .into_iter()
            .filter(|v| org_asset_ids.contains(&v.asset_id))
            .collect();

        assert_eq!(org_vulns.len(), 4);

        // Test vulnerability statistics by severity
        // Count using organization's assets for proper filtering
        let critical_count = vuln_repo
            .count_vulnerabilities(Some(org.id), None, Some(Severity::Critical), None)
            .await
            .expect("Failed to count critical vulnerabilities");

        let medium_count = vuln_repo
            .count_vulnerabilities(Some(org.id), None, Some(Severity::Medium), None)
            .await
            .expect("Failed to count medium vulnerabilities");

        // Create a severity stats map
        let mut severity_stats = std::collections::HashMap::new();
        severity_stats.insert(Severity::Critical, critical_count);
        severity_stats.insert(Severity::Medium, medium_count);

        assert_eq!(*severity_stats.get(&Severity::Critical).unwrap_or(&0), 2);
        assert_eq!(*severity_stats.get(&Severity::Medium).unwrap_or(&0), 2);

        // Instead of get_vulnerabilities_by_title
        // List all and filter by title
        let all_vulns = vuln_repo
            .list_vulnerabilities(None, None, None, None, 100, 0)
            .await
            .expect("Failed to get all vulnerabilities");

        // Filter for certificate vulnerabilities
        let cert_vulns: Vec<_> = all_vulns
            .into_iter()
            .filter(|v| v.title == "Expired TLS Certificate")
            .collect();

        assert_eq!(cert_vulns.len(), 2);

        // Clean up
        let vulnerabilities = vec![
            vuln1_created.id,
            vuln2_created.id,
            vuln3_created.id,
            vuln4_created.id,
        ];

        for vuln_id in vulnerabilities {
            let _ = vuln_repo
                .delete_vulnerability(vuln_id)
                .await
                .expect("Failed to delete vulnerability");
        }

        let assets = vec![
            web_app1_asset.id,
            web_app2_asset.id,
            subdomain1_asset.id,
            subdomain2_asset.id,
            domain_asset.id,
        ];

        for asset_id in assets {
            let _ = asset_repo
                .delete_asset(asset_id)
                .await
                .expect("Failed to delete asset");
        }

        let _ = factory
            .organization_repository()
            .delete_organization(org.id)
            .await
            .expect("Failed to delete organization");
    }
}
