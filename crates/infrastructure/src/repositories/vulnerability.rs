use crate::utils::{
    from_offset_datetime, from_option_bigdecimal, from_option_offset_datetime, to_offset_datetime,
    to_option_bigdecimal, to_option_offset_datetime,
};
use async_trait::async_trait;
use backend::{models::Vulnerability, traits::VulnerabilityRepository, Result};
use shared::types::{Severity, VulnerabilityStatus, ID};
use sqlx::PgPool;

/// PostgreSQL implementation of the Vulnerability Repository
pub struct PgVulnerabilityRepository {
    pool: PgPool,
}

impl PgVulnerabilityRepository {
    /// Create a new PgVulnerabilityRepository instance
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl VulnerabilityRepository for PgVulnerabilityRepository {
    async fn create_vulnerability(&self, vulnerability: &Vulnerability) -> Result<Vulnerability> {
        // Convert DateTime and BigDecimal types for database operation
        let first_seen = to_offset_datetime(vulnerability.first_seen);
        let last_seen = to_offset_datetime(vulnerability.last_seen);
        let resolved_at = to_option_offset_datetime(vulnerability.resolved_at);
        let created_at = to_offset_datetime(vulnerability.created_at);
        let updated_at = to_offset_datetime(vulnerability.updated_at);
        let cvss_score = to_option_bigdecimal(vulnerability.cvss_score);

        let record = sqlx::query!(
            r#"
            INSERT INTO vulnerabilities (
                id, asset_id, port_id, title, description, severity, status,
                cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                resolved_at, created_at, updated_at
            )
            VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
            )
            RETURNING 
                id, asset_id, port_id, title, description, 
                severity as "severity: Severity", status as "status: VulnerabilityStatus",
                cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                resolved_at, created_at, updated_at
            "#,
            vulnerability.id,
            vulnerability.asset_id,
            vulnerability.port_id,
            vulnerability.title,
            vulnerability.description,
            vulnerability.severity as Severity,
            vulnerability.status as VulnerabilityStatus,
            vulnerability.cve_id,
            cvss_score,
            vulnerability.evidence,
            vulnerability.remediation,
            first_seen,
            last_seen,
            resolved_at,
            created_at,
            updated_at
        )
        .fetch_one(&self.pool)
        .await?;

        // Convert back from DB types to model types
        Ok(Vulnerability {
            id: record.id,
            asset_id: record.asset_id,
            port_id: record.port_id,
            title: record.title,
            description: record.description,
            severity: record.severity,
            status: record
                .status
                .expect("Vulnerability status should not be null"),
            cve_id: record.cve_id,
            cvss_score: from_option_bigdecimal(record.cvss_score),
            evidence: record
                .evidence
                .expect("Vulnerability evidence should not be null"),
            remediation: record.remediation,
            first_seen: from_offset_datetime(Some(record.first_seen)),
            last_seen: from_offset_datetime(Some(record.last_seen)),
            resolved_at: from_option_offset_datetime(record.resolved_at),
            created_at: from_offset_datetime(Some(record.created_at)),
            updated_at: from_offset_datetime(Some(record.updated_at)),
        })
    }

    async fn get_vulnerability(&self, id: ID) -> Result<Vulnerability> {
        let record = sqlx::query!(
            r#"
            SELECT 
                id, asset_id, port_id, title, description, 
                severity as "severity: Severity", status as "status: VulnerabilityStatus",
                cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                resolved_at, created_at, updated_at
            FROM vulnerabilities
            WHERE id = $1
            "#,
            id
        )
        .fetch_one(&self.pool)
        .await?;

        // Convert from DB types to model types
        Ok(Vulnerability {
            id: record.id,
            asset_id: record.asset_id,
            port_id: record.port_id,
            title: record.title,
            description: record.description,
            severity: record.severity,
            status: record
                .status
                .expect("Vulnerability status should not be null"),
            cve_id: record.cve_id,
            cvss_score: from_option_bigdecimal(record.cvss_score),
            evidence: record
                .evidence
                .expect("Vulnerability evidence should not be null"),
            remediation: record.remediation,
            first_seen: from_offset_datetime(Some(record.first_seen)),
            last_seen: from_offset_datetime(Some(record.last_seen)),
            resolved_at: from_option_offset_datetime(record.resolved_at),
            created_at: from_offset_datetime(Some(record.created_at)),
            updated_at: from_offset_datetime(Some(record.updated_at)),
        })
    }

    async fn update_vulnerability(&self, vulnerability: &Vulnerability) -> Result<Vulnerability> {
        // Convert DateTime and BigDecimal types for database operation
        let first_seen = to_offset_datetime(vulnerability.first_seen);
        let last_seen = to_offset_datetime(vulnerability.last_seen);
        let resolved_at = to_option_offset_datetime(vulnerability.resolved_at);
        let updated_at = to_offset_datetime(vulnerability.updated_at);
        let cvss_score = to_option_bigdecimal(vulnerability.cvss_score);

        let record = sqlx::query!(
            r#"
            UPDATE vulnerabilities
            SET 
                asset_id = $2, port_id = $3, title = $4, description = $5,
                severity = $6, status = $7, cve_id = $8, cvss_score = $9,
                evidence = $10, remediation = $11, first_seen = $12, last_seen = $13,
                resolved_at = $14, updated_at = $15
            WHERE id = $1
            RETURNING 
                id, asset_id, port_id, title, description, 
                severity as "severity: Severity", status as "status: VulnerabilityStatus",
                cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                resolved_at, created_at, updated_at
            "#,
            vulnerability.id,
            vulnerability.asset_id,
            vulnerability.port_id,
            vulnerability.title,
            vulnerability.description,
            vulnerability.severity as Severity,
            vulnerability.status as VulnerabilityStatus,
            vulnerability.cve_id,
            cvss_score,
            vulnerability.evidence,
            vulnerability.remediation,
            first_seen,
            last_seen,
            resolved_at,
            updated_at
        )
        .fetch_one(&self.pool)
        .await?;

        // Convert back from DB types to model types
        Ok(Vulnerability {
            id: record.id,
            asset_id: record.asset_id,
            port_id: record.port_id,
            title: record.title,
            description: record.description,
            severity: record.severity,
            status: record
                .status
                .expect("Vulnerability status should not be null"),
            cve_id: record.cve_id,
            cvss_score: from_option_bigdecimal(record.cvss_score),
            evidence: record
                .evidence
                .expect("Vulnerability evidence should not be null"),
            remediation: record.remediation,
            first_seen: from_offset_datetime(Some(record.first_seen)),
            last_seen: from_offset_datetime(Some(record.last_seen)),
            resolved_at: from_option_offset_datetime(record.resolved_at),
            created_at: from_offset_datetime(Some(record.created_at)),
            updated_at: from_offset_datetime(Some(record.updated_at)),
        })
    }

    async fn delete_vulnerability(&self, id: ID) -> Result<bool> {
        let result = sqlx::query!(
            r#"
            DELETE FROM vulnerabilities
            WHERE id = $1
            "#,
            id
        )
        .execute(&self.pool)
        .await?;

        Ok(result.rows_affected() > 0)
    }

    async fn list_vulnerabilities(
        &self,
        asset_id: Option<ID>,
        _port_id: Option<ID>,
        _severity: Option<Severity>,
        _status: Option<VulnerabilityStatus>,
        limit: usize,
        offset: usize,
    ) -> Result<Vec<Vulnerability>> {
        let vulnerabilities = if let Some(id) = asset_id {
            let records = sqlx::query!(
                r#"
                SELECT 
                    id, asset_id, port_id, title, description, 
                    severity as "severity: Severity", status as "status: VulnerabilityStatus",
                    cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                    resolved_at, created_at, updated_at
                FROM vulnerabilities
                WHERE asset_id = $1
                ORDER BY severity, title
                LIMIT $2 OFFSET $3
                "#,
                id,
                limit as i64,
                offset as i64
            )
            .fetch_all(&self.pool)
            .await?;

            records
                .into_iter()
                .map(|record| Vulnerability {
                    id: record.id,
                    asset_id: record.asset_id,
                    port_id: record.port_id,
                    title: record.title,
                    description: record.description,
                    severity: record.severity,
                    status: record.status.expect("status should not be null"),
                    cve_id: record.cve_id,
                    cvss_score: from_option_bigdecimal(record.cvss_score),
                    evidence: record.evidence.expect("evidence should not be null"),
                    remediation: record.remediation,
                    first_seen: from_offset_datetime(Some(record.first_seen)),
                    last_seen: from_offset_datetime(Some(record.last_seen)),
                    resolved_at: from_option_offset_datetime(record.resolved_at),
                    created_at: from_offset_datetime(Some(record.created_at)),
                    updated_at: from_offset_datetime(Some(record.updated_at)),
                })
                .collect()
        } else {
            let records = sqlx::query!(
                r#"
                SELECT 
                    id, asset_id, port_id, title, description, 
                    severity as "severity: Severity", status as "status: VulnerabilityStatus",
                    cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                    resolved_at, created_at, updated_at
                FROM vulnerabilities
                ORDER BY severity, title
                LIMIT $1 OFFSET $2
                "#,
                limit as i64,
                offset as i64
            )
            .fetch_all(&self.pool)
            .await?;

            records
                .into_iter()
                .map(|record| Vulnerability {
                    id: record.id,
                    asset_id: record.asset_id,
                    port_id: record.port_id,
                    title: record.title,
                    description: record.description,
                    severity: record.severity,
                    status: record.status.expect("status should not be null"),
                    cve_id: record.cve_id,
                    cvss_score: from_option_bigdecimal(record.cvss_score),
                    evidence: record.evidence.expect("evidence should not be null"),
                    remediation: record.remediation,
                    first_seen: from_offset_datetime(Some(record.first_seen)),
                    last_seen: from_offset_datetime(Some(record.last_seen)),
                    resolved_at: from_option_offset_datetime(record.resolved_at),
                    created_at: from_offset_datetime(Some(record.created_at)),
                    updated_at: from_offset_datetime(Some(record.updated_at)),
                })
                .collect()
        };

        Ok(vulnerabilities)
    }

    async fn count_vulnerabilities(
        &self,
        asset_id: Option<ID>,
        _port_id: Option<ID>,
        _severity: Option<Severity>,
        _status: Option<VulnerabilityStatus>,
    ) -> Result<usize> {
        let count = match asset_id {
            Some(id) => {
                sqlx::query_scalar!(
                    r#"
                    SELECT COUNT(*) as count
                    FROM vulnerabilities
                    WHERE asset_id = $1
                    "#,
                    id
                )
                .fetch_one(&self.pool)
                .await?
            }
            None => {
                sqlx::query_scalar!(
                    r#"
                    SELECT COUNT(*) as count
                    FROM vulnerabilities
                    "#
                )
                .fetch_one(&self.pool)
                .await?
            }
        };

        Ok(count.unwrap_or(0) as usize)
    }
}
