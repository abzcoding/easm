use crate::utils::{
    from_offset_datetime, from_option_bigdecimal, from_option_offset_datetime, to_offset_datetime,
    to_option_bigdecimal, to_option_offset_datetime,
};
use async_trait::async_trait;
use backend::{models::Vulnerability, traits::VulnerabilityRepository, Result};
use shared::types::{Severity, VulnerabilityStatus, ID};
use sqlx::{PgPool, Row};

/// PostgreSQL implementation of the Vulnerability Repository
pub struct PgVulnerabilityRepository {
    pool: PgPool,
}

impl PgVulnerabilityRepository {
    /// Create a new PgVulnerabilityRepository instance
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }

    /// Convert Severity enum to database string representation
    fn severity_to_string(severity: Severity) -> &'static str {
        match severity {
            Severity::Info => "INFO",
            Severity::Low => "LOW",
            Severity::Medium => "MEDIUM",
            Severity::High => "HIGH",
            Severity::Critical => "CRITICAL",
        }
    }

    /// Convert VulnerabilityStatus enum to database string representation
    fn status_to_string(status: VulnerabilityStatus) -> &'static str {
        match status {
            VulnerabilityStatus::Open => "OPEN",
            VulnerabilityStatus::Closed => "CLOSED",
            VulnerabilityStatus::AcceptedRisk => "ACCEPTEDRISK",
            VulnerabilityStatus::FalsePositive => "FALSEPOSITIVE",
        }
    }

    /// Helper to apply vulnerability filters to SQL query
    fn apply_filters(
        query: &mut String,
        asset_id: Option<ID>,
        port_id: Option<ID>,
        severity: Option<Severity>,
        status: Option<VulnerabilityStatus>,
        is_org_query: bool,
    ) {
        // Add asset_id filter if provided
        if let Some(aid) = asset_id {
            query.push_str(&format!(" WHERE asset_id = '{}'", aid));
        } else if is_org_query {
            // For organization queries
            query.push_str(" WHERE 1=1");
        } else {
            // General query with no asset_id
            query.push_str(" WHERE 1=1");
        }

        // Add port_id filter if provided
        if let Some(pid) = port_id {
            let prefix = if is_org_query {
                " AND v.port_id = '"
            } else {
                " AND port_id = '"
            };
            query.push_str(&format!("{}{}'", prefix, pid));
        }

        // Add severity filter if provided
        if let Some(sev) = severity {
            let prefix = if is_org_query {
                " AND v.severity = '"
            } else {
                " AND severity = '"
            };
            // Convert severity enum to string using helper
            let severity_str = Self::severity_to_string(sev);
            query.push_str(&format!("{}{}'", prefix, severity_str));
        }

        // Add status filter if provided
        if let Some(st) = status {
            let prefix = if is_org_query {
                " AND v.status = '"
            } else {
                " AND status = '"
            };
            // Convert status enum to string using helper
            let status_str = Self::status_to_string(st);
            query.push_str(&format!("{}{}'", prefix, status_str));
        }
    }
}

#[async_trait]
impl VulnerabilityRepository for PgVulnerabilityRepository {
    async fn create_vulnerability(&self, vulnerability: &Vulnerability) -> Result<Vulnerability> {
        let now = chrono::Utc::now();

        let first_seen = to_offset_datetime(now);
        let last_seen = to_offset_datetime(now);
        let created_at = to_offset_datetime(now);
        let updated_at = to_offset_datetime(now);

        let query = r#"
            INSERT INTO vulnerabilities (
                asset_id, port_id, title, description, severity, status,
                cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                created_at, updated_at
            ) VALUES (
                $1, $2, $3, $4, $5, $6,
                $7, $8, $9, $10, $11, $12,
                $13, $14
            )
            RETURNING 
                id, asset_id, port_id, title, description, 
                severity, status,
                cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                resolved_at, created_at, updated_at
        "#;

        let row = sqlx::query(query)
            .bind(vulnerability.asset_id)
            .bind(vulnerability.port_id)
            .bind(&vulnerability.title)
            .bind(&vulnerability.description)
            .bind(vulnerability.severity as Severity)
            .bind(VulnerabilityStatus::Open as VulnerabilityStatus)
            .bind(&vulnerability.cve_id)
            .bind(to_option_bigdecimal(vulnerability.cvss_score))
            .bind(&vulnerability.evidence)
            .bind(&vulnerability.remediation)
            .bind(first_seen)
            .bind(last_seen)
            .bind(created_at)
            .bind(updated_at)
            .fetch_one(&self.pool)
            .await?;

        let vulnerability = Vulnerability {
            id: row.get("id"),
            asset_id: row.get("asset_id"),
            port_id: row.get("port_id"),
            title: row.get("title"),
            description: row.get("description"),
            severity: row.get("severity"),
            status: row.get("status"),
            cve_id: row.get("cve_id"),
            cvss_score: from_option_bigdecimal(row.get("cvss_score")),
            evidence: row.get("evidence"),
            remediation: row.get("remediation"),
            first_seen: from_offset_datetime(row.get("first_seen")),
            last_seen: from_offset_datetime(row.get("last_seen")),
            resolved_at: from_option_offset_datetime(row.get("resolved_at")),
            created_at: from_offset_datetime(row.get("created_at")),
            updated_at: from_offset_datetime(row.get("updated_at")),
        };

        Ok(vulnerability)
    }

    async fn get_vulnerability(&self, id: ID) -> Result<Vulnerability> {
        let query = r#"
            SELECT 
                id, asset_id, port_id, title, description, 
                severity, status,
                cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                resolved_at, created_at, updated_at
            FROM vulnerabilities
            WHERE id = $1
        "#;

        let row_result = sqlx::query(query)
            .bind(id)
            .fetch_optional(&self.pool)
            .await?;

        match row_result {
            Some(row) => {
                let vulnerability = Vulnerability {
                    id: row.get("id"),
                    asset_id: row.get("asset_id"),
                    port_id: row.get("port_id"),
                    title: row.get("title"),
                    description: row.get("description"),
                    severity: row.get("severity"),
                    status: row.get("status"),
                    cve_id: row.get("cve_id"),
                    cvss_score: from_option_bigdecimal(row.get("cvss_score")),
                    evidence: row.get("evidence"),
                    remediation: row.get("remediation"),
                    first_seen: from_offset_datetime(row.get("first_seen")),
                    last_seen: from_offset_datetime(row.get("last_seen")),
                    resolved_at: from_option_offset_datetime(row.get("resolved_at")),
                    created_at: from_offset_datetime(row.get("created_at")),
                    updated_at: from_offset_datetime(row.get("updated_at")),
                };

                Ok(vulnerability)
            }
            None => Err(backend::Error::NotFound(format!(
                "Vulnerability not found: {}",
                id
            ))),
        }
    }

    async fn update_vulnerability(&self, vulnerability: &Vulnerability) -> Result<Vulnerability> {
        let now = chrono::Utc::now();
        let resolved_at = if vulnerability.status == VulnerabilityStatus::Closed
            && vulnerability.resolved_at.is_none()
        {
            Some(now)
        } else {
            vulnerability.resolved_at
        };

        let query = r#"
            UPDATE vulnerabilities
            SET
                asset_id = $1,
                port_id = $2,
                title = $3,
                description = $4,
                severity = $5,
                status = $6,
                cve_id = $7,
                cvss_score = $8,
                evidence = $9,
                remediation = $10,
                last_seen = $11,
                resolved_at = $12,
                updated_at = $13
            WHERE id = $14
            RETURNING 
                id, asset_id, port_id, title, description, 
                severity, status,
                cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                resolved_at, created_at, updated_at
        "#;

        let row = sqlx::query(query)
            .bind(vulnerability.asset_id)
            .bind(vulnerability.port_id)
            .bind(&vulnerability.title)
            .bind(&vulnerability.description)
            .bind(vulnerability.severity as Severity)
            .bind(vulnerability.status as VulnerabilityStatus)
            .bind(&vulnerability.cve_id)
            .bind(to_option_bigdecimal(vulnerability.cvss_score))
            .bind(&vulnerability.evidence)
            .bind(&vulnerability.remediation)
            .bind(to_offset_datetime(vulnerability.last_seen))
            .bind(to_option_offset_datetime(resolved_at))
            .bind(to_offset_datetime(now))
            .bind(vulnerability.id)
            .fetch_one(&self.pool)
            .await?;

        let updated_vulnerability = Vulnerability {
            id: row.get("id"),
            asset_id: row.get("asset_id"),
            port_id: row.get("port_id"),
            title: row.get("title"),
            description: row.get("description"),
            severity: row.get("severity"),
            status: row.get("status"),
            cve_id: row.get("cve_id"),
            cvss_score: from_option_bigdecimal(row.get("cvss_score")),
            evidence: row.get("evidence"),
            remediation: row.get("remediation"),
            first_seen: from_offset_datetime(row.get("first_seen")),
            last_seen: from_offset_datetime(row.get("last_seen")),
            resolved_at: from_option_offset_datetime(row.get("resolved_at")),
            created_at: from_offset_datetime(row.get("created_at")),
            updated_at: from_offset_datetime(row.get("updated_at")),
        };

        Ok(updated_vulnerability)
    }

    async fn delete_vulnerability(&self, id: ID) -> Result<bool> {
        let result = sqlx::query!("DELETE FROM vulnerabilities WHERE id = $1", id)
            .execute(&self.pool)
            .await?;

        Ok(result.rows_affected() > 0)
    }

    async fn list_vulnerabilities(
        &self,
        asset_id: Option<ID>,
        port_id: Option<ID>,
        severity: Option<Severity>,
        status: Option<VulnerabilityStatus>,
        limit: usize,
        offset: usize,
    ) -> Result<Vec<Vulnerability>> {
        // First try to list by asset_id
        if let Some(id) = asset_id {
            // Build query for asset_id search with filters
            let mut query = String::from(
                "SELECT 
                    id, asset_id, port_id, title, description, 
                    severity, status,
                    cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                    resolved_at, created_at, updated_at
                FROM vulnerabilities",
            );

            Self::apply_filters(&mut query, Some(id), port_id, severity, status, false);

            // Add order by and limit/offset
            query.push_str(&format!(
                " ORDER BY severity, title LIMIT {} OFFSET {}",
                limit, offset
            ));

            // Execute query
            let rows = sqlx::query(&query).fetch_all(&self.pool).await?;

            if !rows.is_empty() {
                // Convert rows to Vulnerability models
                return Ok(rows
                    .into_iter()
                    .map(|row| Vulnerability {
                        id: row.get("id"),
                        asset_id: row.get("asset_id"),
                        port_id: row.get("port_id"),
                        title: row.get("title"),
                        description: row.get("description"),
                        severity: row.get("severity"),
                        status: row.get("status"),
                        cve_id: row.get("cve_id"),
                        cvss_score: from_option_bigdecimal(row.get("cvss_score")),
                        evidence: row.get("evidence"),
                        remediation: row.get("remediation"),
                        first_seen: from_offset_datetime(row.get("first_seen")),
                        last_seen: from_offset_datetime(row.get("last_seen")),
                        resolved_at: from_option_offset_datetime(row.get("resolved_at")),
                        created_at: from_offset_datetime(row.get("created_at")),
                        updated_at: from_offset_datetime(row.get("updated_at")),
                    })
                    .collect());
            }

            // If no results found by asset_id, try organization_id
            let mut org_query = String::from(
                "SELECT 
                    v.id, v.asset_id, v.port_id, v.title, v.description, 
                    v.severity, v.status,
                    v.cve_id, v.cvss_score, v.evidence, v.remediation, v.first_seen, v.last_seen,
                    v.resolved_at, v.created_at, v.updated_at
                FROM vulnerabilities v
                JOIN assets a ON v.asset_id = a.id
                WHERE a.organization_id = $1",
            );

            // Add other filters
            if let Some(sev) = severity {
                // Convert severity enum to string using helper
                let severity_str = Self::severity_to_string(sev);
                org_query.push_str(&format!(" AND v.severity = '{}'", severity_str));
            }

            if let Some(st) = status {
                // Convert status enum to string using helper
                let status_str = Self::status_to_string(st);
                org_query.push_str(&format!(" AND v.status = '{}'", status_str));
            }

            if let Some(pid) = port_id {
                org_query.push_str(&format!(" AND v.port_id = '{}'", pid));
            }

            // Add order by and limit/offset
            org_query.push_str(&format!(
                " ORDER BY v.severity, v.title LIMIT {} OFFSET {}",
                limit, offset
            ));

            // Execute query
            let org_rows = sqlx::query(&org_query)
                .bind(id)
                .fetch_all(&self.pool)
                .await?;

            // Convert rows to Vulnerability models
            return Ok(org_rows
                .into_iter()
                .map(|row| Vulnerability {
                    id: row.get("id"),
                    asset_id: row.get("asset_id"),
                    port_id: row.get("port_id"),
                    title: row.get("title"),
                    description: row.get("description"),
                    severity: row.get("severity"),
                    status: row.get("status"),
                    cve_id: row.get("cve_id"),
                    cvss_score: from_option_bigdecimal(row.get("cvss_score")),
                    evidence: row.get("evidence"),
                    remediation: row.get("remediation"),
                    first_seen: from_offset_datetime(row.get("first_seen")),
                    last_seen: from_offset_datetime(row.get("last_seen")),
                    resolved_at: from_option_offset_datetime(row.get("resolved_at")),
                    created_at: from_offset_datetime(row.get("created_at")),
                    updated_at: from_offset_datetime(row.get("updated_at")),
                })
                .collect());
        }

        // No asset_id filter, search across all vulnerabilities
        let mut query = String::from(
            "SELECT 
                id, asset_id, port_id, title, description, 
                severity, status,
                cve_id, cvss_score, evidence, remediation, first_seen, last_seen,
                resolved_at, created_at, updated_at
            FROM vulnerabilities",
        );

        Self::apply_filters(&mut query, None, port_id, severity, status, false);

        // Add order by and limit/offset
        query.push_str(&format!(
            " ORDER BY severity, title LIMIT {} OFFSET {}",
            limit, offset
        ));

        // Execute query
        let rows = sqlx::query(&query).fetch_all(&self.pool).await?;

        // Convert rows to Vulnerability models
        Ok(rows
            .into_iter()
            .map(|row| Vulnerability {
                id: row.get("id"),
                asset_id: row.get("asset_id"),
                port_id: row.get("port_id"),
                title: row.get("title"),
                description: row.get("description"),
                severity: row.get("severity"),
                status: row.get("status"),
                cve_id: row.get("cve_id"),
                cvss_score: from_option_bigdecimal(row.get("cvss_score")),
                evidence: row.get("evidence"),
                remediation: row.get("remediation"),
                first_seen: from_offset_datetime(row.get("first_seen")),
                last_seen: from_offset_datetime(row.get("last_seen")),
                resolved_at: from_option_offset_datetime(row.get("resolved_at")),
                created_at: from_offset_datetime(row.get("created_at")),
                updated_at: from_offset_datetime(row.get("updated_at")),
            })
            .collect())
    }

    async fn count_vulnerabilities(
        &self,
        asset_id: Option<ID>,
        port_id: Option<ID>,
        severity: Option<Severity>,
        status: Option<VulnerabilityStatus>,
    ) -> Result<usize> {
        // First try to count by asset_id
        if let Some(id) = asset_id {
            // Build query for asset_id search with filters
            let mut query = String::from("SELECT COUNT(*) as count FROM vulnerabilities");

            // Add asset_id filter
            query.push_str(&format!(" WHERE asset_id = '{}'", id));

            // Add port_id filter if provided
            if let Some(pid) = port_id {
                query.push_str(&format!(" AND port_id = '{}'", pid));
            }

            // Add severity filter if provided
            if let Some(sev) = severity {
                // Convert severity enum to string using helper
                let severity_str = Self::severity_to_string(sev);
                query.push_str(&format!(" AND severity = '{}'", severity_str));
            }

            // Add status filter if provided
            if let Some(st) = status {
                // Convert status enum to string using helper
                let status_str = Self::status_to_string(st);
                query.push_str(&format!(" AND status = '{}'", status_str));
            }

            // Execute query
            let row = sqlx::query(&query).fetch_one(&self.pool).await?;

            let count: i64 = row.get("count");

            if count > 0 {
                return Ok(count as usize);
            }

            // If no results found by asset_id, try organization_id
            let mut org_query = String::from(
                "SELECT COUNT(*) as count
                FROM vulnerabilities v
                JOIN assets a ON v.asset_id = a.id
                WHERE a.organization_id = $1",
            );

            // Add other filters
            if let Some(sev) = severity {
                // Convert severity enum to string using helper
                let severity_str = Self::severity_to_string(sev);
                org_query.push_str(&format!(" AND v.severity = '{}'", severity_str));
            }

            if let Some(st) = status {
                // Convert status enum to string using helper
                let status_str = Self::status_to_string(st);
                org_query.push_str(&format!(" AND v.status = '{}'", status_str));
            }

            if let Some(pid) = port_id {
                org_query.push_str(&format!(" AND v.port_id = '{}'", pid));
            }

            // Execute query
            let org_row = sqlx::query(&org_query)
                .bind(id)
                .fetch_one(&self.pool)
                .await?;

            let org_count: i64 = org_row.get("count");
            return Ok(org_count as usize);
        }

        // No asset_id filter, count across all vulnerabilities
        let mut query = String::from("SELECT COUNT(*) as count FROM vulnerabilities");

        // No asset_id, so start with WHERE 1=1 to make adding filters easier
        query.push_str(" WHERE 1=1");

        // Add port_id filter if provided
        if let Some(pid) = port_id {
            query.push_str(&format!(" AND port_id = '{}'", pid));
        }

        // Add severity filter if provided
        if let Some(sev) = severity {
            // Convert severity enum to string using helper
            let severity_str = Self::severity_to_string(sev);
            query.push_str(&format!(" AND severity = '{}'", severity_str));
        }

        // Add status filter if provided
        if let Some(st) = status {
            // Convert status enum to string using helper
            let status_str = Self::status_to_string(st);
            query.push_str(&format!(" AND status = '{}'", status_str));
        }

        // Execute query
        let row = sqlx::query(&query).fetch_one(&self.pool).await?;

        let count: i64 = row.get("count");
        Ok(count as usize)
    }
}
