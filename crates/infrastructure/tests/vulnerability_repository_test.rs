#[cfg(test)]
mod tests {
    use backend::models::{Asset, Vulnerability};
    use infrastructure::{
        repositories::factory::RepositoryFactory,
        utils::testing::{create_test_asset, create_test_organization, setup_test_db},
    };
    use shared::types::{AssetType, Severity, VulnerabilityStatus, ID};

    use rand;

    // Helper to create a test vulnerability
    async fn create_test_vulnerability(
        factory: &RepositoryFactory,
        asset: &Asset,
        title: &str,
        severity: Severity,
    ) -> Vulnerability {
        let vuln = Vulnerability::new(
            asset.id,
            None, // port_id
            title.to_string(),
            Some(format!("Description for {}", title)),
            severity,
            Some(format!("CVE-TEST-{}", rand::random::<u16>())),
            None, // evidence
            Some("Remediation steps".to_string()),
        );
        factory
            .vulnerability_repository()
            .create_vulnerability(&vuln)
            .await
            .expect("Failed to create test vulnerability")
    }

    #[tokio::test]
    async fn test_vulnerability_repository_basic_operations() {
        let (db_pool, _container) = setup_test_db().await;
        let factory = RepositoryFactory::new(db_pool);
        let vuln_repo = factory.vulnerability_repository();

        // Setup: Create org and asset
        let org = create_test_organization(&factory, "Test Org Vuln Repo")
            .await
            .unwrap();
        let asset = create_test_asset(&factory, org.id, AssetType::Domain, "vuln.com")
            .await
            .unwrap();

        // 1. Create Vulnerability
        let created_vuln =
            create_test_vulnerability(&factory, &asset, "Test Vuln CRUD", Severity::High).await;
        assert_eq!(created_vuln.title, "Test Vuln CRUD");
        assert_eq!(created_vuln.asset_id, asset.id);
        assert_eq!(created_vuln.severity, Severity::High);

        // 2. Get Vulnerability
        let found_vuln = vuln_repo
            .get_vulnerability(created_vuln.id)
            .await
            .expect("Failed to get vulnerability");
        assert_eq!(found_vuln.id, created_vuln.id);

        // 3. Update Vulnerability
        let mut vuln_to_update = found_vuln.clone();
        vuln_to_update.status = VulnerabilityStatus::Closed;
        vuln_to_update.severity = Severity::Medium;
        let updated_vuln = vuln_repo
            .update_vulnerability(&vuln_to_update)
            .await
            .expect("Failed to update vulnerability");
        assert_eq!(updated_vuln.id, created_vuln.id);
        assert_eq!(updated_vuln.status, VulnerabilityStatus::Closed);
        assert_eq!(updated_vuln.severity, Severity::Medium);

        // Verify update
        let verified_vuln = vuln_repo
            .get_vulnerability(created_vuln.id)
            .await
            .expect("Failed to get vulnerability after update");
        assert_eq!(verified_vuln.status, VulnerabilityStatus::Closed);

        // 4. Delete Vulnerability
        let deleted = vuln_repo
            .delete_vulnerability(created_vuln.id)
            .await
            .expect("Failed to delete vulnerability");
        assert!(deleted);

        // Verify deletion
        let not_found_result = vuln_repo.get_vulnerability(created_vuln.id).await;
        assert!(not_found_result.is_err());
    }

    #[tokio::test]
    async fn test_vulnerability_repository_list_and_filters() {
        let (db_pool, _container) = setup_test_db().await;
        let factory = RepositoryFactory::new(db_pool);
        let vuln_repo = factory.vulnerability_repository();

        // Setup: Create org, assets, and vulnerabilities
        let org = create_test_organization(&factory, "Test Org Vuln List")
            .await
            .unwrap();
        let asset1 = create_test_asset(&factory, org.id, AssetType::Domain, "vuln1.com")
            .await
            .unwrap();
        let asset2 = create_test_asset(&factory, org.id, AssetType::IPAddress, "1.1.1.1")
            .await
            .unwrap();

        let vuln1_asset1_high =
            create_test_vulnerability(&factory, &asset1, "Vuln 1 A1 H", Severity::High).await;
        let vuln2_asset1_medium_open =
            create_test_vulnerability(&factory, &asset1, "Vuln 2 A1 M", Severity::Medium).await;
        let mut vuln3_asset1_low_closed =
            create_test_vulnerability(&factory, &asset1, "Vuln 3 A1 L", Severity::Low).await;
        vuln3_asset1_low_closed.status = VulnerabilityStatus::Closed;
        vuln_repo
            .update_vulnerability(&vuln3_asset1_low_closed)
            .await
            .unwrap();

        let _vuln4_asset2_critical =
            create_test_vulnerability(&factory, &asset2, "Vuln 4 A2 C", Severity::Critical).await;

        let limit = 10;
        let offset = 0;

        // List all for Asset 1
        let vulns_asset1 = vuln_repo
            .list_vulnerabilities(Some(asset1.id), None, None, None, limit, offset)
            .await
            .expect("Failed to list vulns for asset 1");
        assert_eq!(vulns_asset1.len(), 3);

        // List High severity for Asset 1
        let high_vulns_asset1 = vuln_repo
            .list_vulnerabilities(
                Some(asset1.id),
                None,
                Some(Severity::High),
                None,
                limit,
                offset,
            )
            .await
            .expect("Failed to list high severity vulns for asset 1");
        assert_eq!(high_vulns_asset1.len(), 1);
        assert_eq!(high_vulns_asset1[0].id, vuln1_asset1_high.id);

        // List Open status for Asset 1
        let open_vulns_asset1 = vuln_repo
            .list_vulnerabilities(
                Some(asset1.id),
                None,
                None,
                Some(VulnerabilityStatus::Open),
                limit,
                offset,
            )
            .await
            .expect("Failed to list open vulns for asset 1");
        assert_eq!(open_vulns_asset1.len(), 2);
        // Check IDs are vuln1 and vuln2
        let open_ids: Vec<ID> = open_vulns_asset1.iter().map(|v| v.id).collect();
        assert!(open_ids.contains(&vuln1_asset1_high.id));
        assert!(open_ids.contains(&vuln2_asset1_medium_open.id));

        // List Medium severity AND Open status for Asset 1
        let medium_open_vulns_asset1 = vuln_repo
            .list_vulnerabilities(
                Some(asset1.id),
                None,
                Some(Severity::Medium),
                Some(VulnerabilityStatus::Open),
                limit,
                offset,
            )
            .await
            .expect("Failed to list medium open vulns for asset 1");
        assert_eq!(medium_open_vulns_asset1.len(), 1);
        assert_eq!(medium_open_vulns_asset1[0].id, vuln2_asset1_medium_open.id);

        // Count all for Asset 1
        let count_asset1 = vuln_repo
            .count_vulnerabilities(Some(asset1.id), None, None, None)
            .await
            .expect("Failed to count vulns for asset 1");
        assert_eq!(count_asset1, 3);

        // Count Open status for Asset 1
        let count_open_asset1 = vuln_repo
            .count_vulnerabilities(Some(asset1.id), None, None, Some(VulnerabilityStatus::Open))
            .await
            .expect("Failed to count open vulns for asset 1");
        assert_eq!(count_open_asset1, 2);

        // Count High severity for Asset 1
        let count_high_asset1 = vuln_repo
            .count_vulnerabilities(Some(asset1.id), None, Some(Severity::High), None)
            .await
            .expect("Failed to count high vulns for asset 1");
        // TODO: Fix this assertion. Expected 1, but got 3. Filter seems broken.
        assert_eq!(count_high_asset1, 1);

        // Count all vulnerabilities across all assets (no filters)
        let count_all = vuln_repo
            .count_vulnerabilities(None, None, None, None)
            .await
            .expect("Failed to count all vulns");
        assert_eq!(count_all, 4);
    }
}
