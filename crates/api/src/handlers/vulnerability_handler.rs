use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
};
use backend::models::Vulnerability;
use chrono::Utc;
use serde::{Deserialize, Serialize};
use serde_json;
use shared::types::{Severity, VulnerabilityStatus, ID};
use std::{collections::HashMap, sync::Arc};
use uuid::Uuid;

use crate::{
    errors::{convert_result, Result},
    state::AppState,
};

#[derive(Debug, Deserialize)]
pub struct VulnerabilityQuery {
    asset_id: Option<Uuid>,
    port_id: Option<Uuid>,
    severity: Option<Severity>,
    status: Option<VulnerabilityStatus>,
    limit: Option<usize>,
    offset: Option<usize>,
}

#[derive(Debug, Serialize)]
pub struct VulnerabilityListResponse {
    vulnerabilities: Vec<Vulnerability>,
    total: usize,
}

/// Response for correlated vulnerabilities
#[derive(Debug, Serialize)]
pub struct CorrelatedVulnerabilityResponse {
    /// Map of vulnerability IDs to related vulnerability IDs
    correlations: HashMap<ID, Vec<ID>>,
}

/// Query parameters for correlation
#[derive(Debug, Deserialize)]
pub struct CorrelationQuery {
    /// Organization ID to correlate vulnerabilities for
    organization_id: Uuid,
    /// Minimum severity level to consider
    min_severity: Option<Severity>,
}

/// Query parameters for similar vulnerabilities
#[derive(Debug, Deserialize)]
pub struct SimilarVulnerabilityQuery {
    /// Maximum number of similar vulnerabilities to return
    limit: Option<usize>,
}

/// DTO for creating a new vulnerability without requiring an ID
#[derive(Debug, Deserialize)]
pub struct CreateVulnerabilityDto {
    /// Associated asset ID
    pub asset_id: ID,

    /// Associated port ID (optional)
    pub port_id: Option<ID>,

    /// Title of the vulnerability
    pub title: String,

    /// Detailed description
    pub description: Option<String>,

    /// Severity level
    pub severity: Severity,

    /// CVE identifier if applicable
    pub cve_id: Option<String>,

    /// Evidence data as JSON
    pub evidence: Option<serde_json::Value>,

    /// Recommended remediation steps
    pub remediation: Option<String>,
}

/// List vulnerabilities with optional filters
pub async fn list_vulnerabilities(
    State(state): State<Arc<AppState>>,
    Query(query): Query<VulnerabilityQuery>,
) -> Result<Json<VulnerabilityListResponse>> {
    // Get vulnerabilities from service
    let vulnerabilities = convert_result(
        state
            .vulnerability_service
            .list_vulnerabilities(
                query.asset_id,
                query.port_id,
                query.severity,
                query.status,
                query.limit.unwrap_or(20),
                query.offset.unwrap_or(0),
            )
            .await,
    )?;

    // Get total count for pagination
    let total = convert_result(
        state
            .vulnerability_service
            .count_vulnerabilities(query.asset_id, query.port_id, query.severity, query.status)
            .await,
    )?;

    Ok(Json(VulnerabilityListResponse {
        vulnerabilities,
        total,
    }))
}

/// Get a single vulnerability by ID
pub async fn get_vulnerability(
    State(state): State<Arc<AppState>>,
    Path(id): Path<ID>,
) -> Result<Json<Vulnerability>> {
    let vulnerability = convert_result(state.vulnerability_service.get_vulnerability(id).await)?;
    Ok(Json(vulnerability))
}

/// Create a new vulnerability
pub async fn create_vulnerability(
    State(state): State<Arc<AppState>>,
    Json(vulnerability): Json<CreateVulnerabilityDto>,
) -> Result<(StatusCode, Json<Vulnerability>)> {
    // Convert request to vulnerability model
    let vulnerability_model = Vulnerability {
        id: Uuid::new_v4(),
        asset_id: vulnerability.asset_id,
        port_id: vulnerability.port_id,
        title: vulnerability.title,
        description: vulnerability.description,
        severity: vulnerability.severity,
        status: VulnerabilityStatus::Open,
        cve_id: vulnerability.cve_id,
        cvss_score: Some(0.0),
        evidence: vulnerability
            .evidence
            .unwrap_or_else(|| serde_json::json!({})),
        remediation: vulnerability.remediation,
        first_seen: Utc::now(),
        last_seen: Utc::now(),
        resolved_at: None,
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };

    let created_vulnerability = convert_result(
        state
            .vulnerability_service
            .create_vulnerability(&vulnerability_model)
            .await,
    )?;

    Ok((StatusCode::CREATED, Json(created_vulnerability)))
}

/// Update an existing vulnerability
pub async fn update_vulnerability(
    State(state): State<Arc<AppState>>,
    Path(id): Path<ID>,
    Json(mut vulnerability): Json<Vulnerability>,
) -> Result<Json<Vulnerability>> {
    // Ensure ID in path matches body
    if vulnerability.id != id {
        vulnerability.id = id;
    }

    let updated_vulnerability = convert_result(
        state
            .vulnerability_service
            .update_vulnerability(&vulnerability)
            .await,
    )?;

    Ok(Json(updated_vulnerability))
}

/// Delete a vulnerability by ID
pub async fn delete_vulnerability(
    State(state): State<Arc<AppState>>,
    Path(id): Path<ID>,
) -> Result<StatusCode> {
    convert_result(state.vulnerability_service.delete_vulnerability(id).await)?;
    Ok(StatusCode::NO_CONTENT)
}

/// Correlate vulnerabilities across assets in an organization
pub async fn correlate_vulnerabilities(
    State(state): State<Arc<AppState>>,
    Query(query): Query<CorrelationQuery>,
) -> Result<Json<CorrelatedVulnerabilityResponse>> {
    let correlations = convert_result(
        state
            .vulnerability_service
            .correlate_vulnerabilities(query.organization_id, query.min_severity)
            .await,
    )?;

    Ok(Json(CorrelatedVulnerabilityResponse { correlations }))
}

/// Find similar vulnerabilities to a specific vulnerability
pub async fn find_similar_vulnerabilities(
    State(state): State<Arc<AppState>>,
    Path(id): Path<ID>,
    Query(query): Query<SimilarVulnerabilityQuery>,
) -> Result<Json<VulnerabilityListResponse>> {
    let limit = query.limit.unwrap_or(10);

    let similar_vulnerabilities = convert_result(
        state
            .vulnerability_service
            .find_similar_vulnerabilities(id, limit)
            .await,
    )?;

    let total = similar_vulnerabilities.len();

    Ok(Json(VulnerabilityListResponse {
        vulnerabilities: similar_vulnerabilities,
        total,
    }))
}
