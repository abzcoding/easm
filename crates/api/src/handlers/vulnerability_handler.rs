use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
};
use backend::models::Vulnerability;
use serde::{Deserialize, Serialize};
use serde_json;
use shared::types::{Severity, VulnerabilityStatus, ID};
use std::{collections::HashMap, sync::Arc};
use uuid::Uuid;

use crate::{errors::Result, state::AppState};

#[derive(Debug, Deserialize)]
pub struct VulnerabilityQuery {
    asset_id: Option<Uuid>,
    port_id: Option<Uuid>,
    severity: Option<Severity>,
    status: Option<VulnerabilityStatus>,
    limit: Option<usize>,
    offset: Option<usize>,
}

#[derive(Debug, Serialize)]
pub struct VulnerabilityListResponse {
    vulnerabilities: Vec<Vulnerability>,
    total: usize,
}

/// Response for correlated vulnerabilities
#[derive(Debug, Serialize)]
pub struct CorrelatedVulnerabilityResponse {
    /// Map of vulnerability IDs to related vulnerability IDs
    correlations: HashMap<ID, Vec<ID>>,
}

/// Query parameters for correlation
#[derive(Debug, Deserialize)]
pub struct CorrelationQuery {
    /// Organization ID to correlate vulnerabilities for
    organization_id: Uuid,
    /// Minimum severity level to consider
    min_severity: Option<Severity>,
}

/// Query parameters for similar vulnerabilities
#[derive(Debug, Deserialize)]
pub struct SimilarVulnerabilityQuery {
    /// Maximum number of similar vulnerabilities to return
    limit: Option<usize>,
}

/// DTO for creating a new vulnerability without requiring an ID
#[derive(Debug, Deserialize)]
pub struct CreateVulnerabilityDto {
    /// Associated asset ID
    pub asset_id: ID,

    /// Associated port ID (optional)
    pub port_id: Option<ID>,

    /// Title of the vulnerability
    pub title: String,

    /// Detailed description
    pub description: Option<String>,

    /// Severity level
    pub severity: Severity,

    /// CVE identifier if applicable
    pub cve_id: Option<String>,

    /// Evidence data as JSON
    pub evidence: Option<serde_json::Value>,

    /// Recommended remediation steps
    pub remediation: Option<String>,
}

/// List vulnerabilities with optional filters
pub async fn list_vulnerabilities(
    State(state): State<Arc<AppState>>,
    Query(query): Query<VulnerabilityQuery>,
) -> Result<Json<VulnerabilityListResponse>> {
    let limit = query.limit.unwrap_or(20);
    let offset = query.offset.unwrap_or(0);

    // Get vulnerabilities from service
    let vulnerabilities = state
        .vulnerability_service
        .list_vulnerabilities(
            query.asset_id,
            query.port_id,
            query.severity,
            query.status,
            limit,
            offset,
        )
        .await?;

    // Get total count for pagination
    let total = state
        .vulnerability_service
        .count_vulnerabilities(query.asset_id, query.port_id, query.severity, query.status)
        .await?;

    Ok(Json(VulnerabilityListResponse {
        vulnerabilities,
        total,
    }))
}

/// Get a single vulnerability by ID
pub async fn get_vulnerability(
    State(state): State<Arc<AppState>>,
    Path(id): Path<ID>,
) -> Result<Json<Vulnerability>> {
    let vulnerability = state.vulnerability_service.get_vulnerability(id).await?;
    Ok(Json(vulnerability))
}

/// Create a new vulnerability
pub async fn create_vulnerability(
    State(state): State<Arc<AppState>>,
    Json(dto): Json<CreateVulnerabilityDto>,
) -> Result<(StatusCode, Json<Vulnerability>)> {
    // Create vulnerability from the DTO using the helper method on Vulnerability
    let vulnerability = Vulnerability::new(
        dto.asset_id,
        dto.port_id,
        dto.title,
        dto.description,
        dto.severity,
        dto.cve_id,
        dto.evidence,
        dto.remediation,
    );

    let created_vulnerability = state
        .vulnerability_service
        .create_vulnerability(&vulnerability)
        .await?;
    Ok((StatusCode::CREATED, Json(created_vulnerability)))
}

/// Update an existing vulnerability
pub async fn update_vulnerability(
    State(state): State<Arc<AppState>>,
    Path(id): Path<ID>,
    Json(mut vulnerability): Json<Vulnerability>,
) -> Result<Json<Vulnerability>> {
    // Ensure ID in path matches body
    if vulnerability.id != id {
        vulnerability.id = id;
    }

    let updated_vulnerability = state
        .vulnerability_service
        .update_vulnerability(&vulnerability)
        .await?;
    Ok(Json(updated_vulnerability))
}

/// Delete a vulnerability by ID
pub async fn delete_vulnerability(
    State(state): State<Arc<AppState>>,
    Path(id): Path<ID>,
) -> Result<StatusCode> {
    state.vulnerability_service.delete_vulnerability(id).await?;
    Ok(StatusCode::NO_CONTENT)
}

/// Correlate vulnerabilities across assets in an organization
pub async fn correlate_vulnerabilities(
    State(state): State<Arc<AppState>>,
    Query(query): Query<CorrelationQuery>,
) -> Result<Json<CorrelatedVulnerabilityResponse>> {
    let correlations = state
        .vulnerability_service
        .correlate_vulnerabilities(query.organization_id, query.min_severity)
        .await?;

    Ok(Json(CorrelatedVulnerabilityResponse { correlations }))
}

/// Find similar vulnerabilities to a specific vulnerability
pub async fn find_similar_vulnerabilities(
    State(state): State<Arc<AppState>>,
    Path(id): Path<ID>,
    Query(query): Query<SimilarVulnerabilityQuery>,
) -> Result<Json<VulnerabilityListResponse>> {
    let limit = query.limit.unwrap_or(10);

    let similar_vulnerabilities = state
        .vulnerability_service
        .find_similar_vulnerabilities(id, limit)
        .await?;

    let total = similar_vulnerabilities.len();

    Ok(Json(VulnerabilityListResponse {
        vulnerabilities: similar_vulnerabilities,
        total,
    }))
}
