use crate::results::DiscoveryResult;
use crate::vulnerability::DiscoveredVulnerability;
use anyhow::Result;
use serde_json::Value;
use std::io::Write;
use std::process::Command;
use tempfile::NamedTempFile;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio::process::Command as AsyncCommand;

pub struct NucleiRunner {
    template_filters: Option<Vec<String>>,
    severity_filter: Option<String>,
    rate_limit: Option<u32>,
}

impl NucleiRunner {
    pub fn new() -> Self {
        NucleiRunner {
            template_filters: None,
            severity_filter: None,
            rate_limit: None,
        }
    }

    pub fn with_templates(mut self, templates: Vec<String>) -> Self {
        self.template_filters = Some(templates);
        self
    }

    pub fn with_severity(mut self, severity: String) -> Self {
        self.severity_filter = Some(severity);
        self
    }

    pub fn with_rate_limit(mut self, rps: u32) -> Self {
        self.rate_limit = Some(rps);
        self
    }

    pub async fn scan_targets(&self, targets: &[String]) -> Result<DiscoveryResult> {
        // Write targets to a temporary file
        let mut temp_file = NamedTempFile::new()?;
        write!(temp_file, "{}", targets.join("\n"))?;

        let mut cmd = AsyncCommand::new("nuclei");
        cmd.args([
            "-l",
            temp_file.path().to_str().unwrap(),
            "-json",
            "-silent",
            "-stats", // Enable statistics
        ]);

        // Apply optional configuration
        if let Some(templates) = &self.template_filters {
            cmd.arg("-t");
            cmd.arg(templates.join(","));
        }

        if let Some(severity) = &self.severity_filter {
            cmd.args(["-severity", severity]);
        }

        if let Some(rate) = self.rate_limit {
            cmd.args(["-rate-limit", &rate.to_string()]);
        }

        let mut child = cmd.stdout(std::process::Stdio::piped()).spawn()?;
        let stdout = child.stdout.take().expect("Failed to get stdout handle");
        let reader = BufReader::new(stdout).lines();

        let mut discovery_result = DiscoveryResult::new();

        // Process output line by line
        let mut reader = reader;
        while let Ok(Some(line)) = reader.next_line().await {
            if let Ok(entry) = serde_json::from_str::<Value>(&line) {
                // Skip statistics entries
                if entry.get("stats").is_some() {
                    continue;
                }

                if let (Some(host), Some(info)) = (
                    entry.get("host").and_then(|h| h.as_str()),
                    entry.get("info"),
                ) {
                    let name = info
                        .get("name")
                        .and_then(|n| n.as_str())
                        .unwrap_or("Unknown");
                    let severity = info
                        .get("severity")
                        .and_then(|s| s.as_str())
                        .unwrap_or("unknown");
                    let template_id = entry
                        .get("template-id")
                        .and_then(|t| t.as_str())
                        .unwrap_or("unknown");
                    let matched_at = entry
                        .get("matched-at")
                        .and_then(|m| m.as_str())
                        .unwrap_or(host);

                    let mut vuln = DiscoveredVulnerability::new(
                        host.to_string(),
                        name.to_string(),
                        severity.to_string(),
                        template_id.to_string(),
                        matched_at.to_string(),
                    );

                    // Parse additional fields if available
                    vuln.description = info
                        .get("description")
                        .and_then(|d| d.as_str())
                        .map(String::from);

                    // Parse references
                    if let Some(references) = info.get("reference").and_then(|r| r.as_array()) {
                        vuln.references = references
                            .iter()
                            .filter_map(|r| r.as_str().map(String::from))
                            .collect();
                    }

                    // Parse tags
                    if let Some(tags) = info.get("tags").and_then(|t| t.as_array()) {
                        vuln.tags = tags
                            .iter()
                            .filter_map(|t| t.as_str().map(String::from))
                            .collect();
                    }

                    // Parse CVE ID
                    if let Some(classification) = info.get("classification") {
                        vuln.cve_id = classification
                            .get("cve-id")
                            .and_then(|c| c.as_array())
                            .and_then(|arr| arr.first())
                            .and_then(|c| c.as_str())
                            .map(String::from);

                        vuln.cvss_score = classification
                            .get("cvss-metrics")
                            .and_then(|c| c.as_str())
                            .and_then(|s| {
                                s.split_whitespace()
                                    .next()
                                    .and_then(|score| score.parse::<f32>().ok())
                            });
                    }

                    discovery_result.raw_vulnerabilities.push(vuln);
                }
            }
        }

        // Wait for the child process to finish
        let status = child.wait().await?;
        if !status.success() {
            tracing::warn!("Nuclei process exited with non-zero status: {}", status);
        }

        Ok(discovery_result)
    }

    pub fn scan_targets_sync(&self, targets: &[String]) -> Result<DiscoveryResult> {
        // Write targets to a temporary file
        let mut temp_file = NamedTempFile::new()?;
        write!(temp_file, "{}", targets.join("\n"))?;

        let mut cmd = Command::new("nuclei");
        cmd.args([
            "-l",
            temp_file.path().to_str().unwrap(),
            "-json",
            "-silent",
            "-stats", // Enable statistics
        ]);

        // Apply optional configuration
        if let Some(templates) = &self.template_filters {
            cmd.arg("-t");
            cmd.arg(templates.join(","));
        }

        if let Some(severity) = &self.severity_filter {
            cmd.args(["-severity", severity]);
        }

        if let Some(rate) = self.rate_limit {
            cmd.args(["-rate-limit", &rate.to_string()]);
        }

        let output = cmd.output()?;
        let mut discovery_result = DiscoveryResult::new();

        // Parse JSON output line by line
        for line in String::from_utf8_lossy(&output.stdout).lines() {
            if let Ok(entry) = serde_json::from_str::<Value>(line) {
                // Skip statistics entries
                if entry.get("stats").is_some() {
                    continue;
                }

                if let (Some(host), Some(info)) = (
                    entry.get("host").and_then(|h| h.as_str()),
                    entry.get("info"),
                ) {
                    let name = info
                        .get("name")
                        .and_then(|n| n.as_str())
                        .unwrap_or("Unknown");
                    let severity = info
                        .get("severity")
                        .and_then(|s| s.as_str())
                        .unwrap_or("unknown");
                    let template_id = entry
                        .get("template-id")
                        .and_then(|t| t.as_str())
                        .unwrap_or("unknown");
                    let matched_at = entry
                        .get("matched-at")
                        .and_then(|m| m.as_str())
                        .unwrap_or(host);

                    let mut vuln = DiscoveredVulnerability::new(
                        host.to_string(),
                        name.to_string(),
                        severity.to_string(),
                        template_id.to_string(),
                        matched_at.to_string(),
                    );

                    // Parse additional fields if available
                    vuln.description = info
                        .get("description")
                        .and_then(|d| d.as_str())
                        .map(String::from);

                    // Parse references
                    if let Some(references) = info.get("reference").and_then(|r| r.as_array()) {
                        vuln.references = references
                            .iter()
                            .filter_map(|r| r.as_str().map(String::from))
                            .collect();
                    }

                    // Parse tags
                    if let Some(tags) = info.get("tags").and_then(|t| t.as_array()) {
                        vuln.tags = tags
                            .iter()
                            .filter_map(|t| t.as_str().map(String::from))
                            .collect();
                    }

                    // Parse CVE ID
                    if let Some(classification) = info.get("classification") {
                        vuln.cve_id = classification
                            .get("cve-id")
                            .and_then(|c| c.as_array())
                            .and_then(|arr| arr.first())
                            .and_then(|c| c.as_str())
                            .map(String::from);

                        vuln.cvss_score = classification
                            .get("cvss-metrics")
                            .and_then(|c| c.as_str())
                            .and_then(|s| {
                                s.split_whitespace()
                                    .next()
                                    .and_then(|score| score.parse::<f32>().ok())
                            });
                    }

                    discovery_result.raw_vulnerabilities.push(vuln);
                }
            }
        }

        Ok(discovery_result)
    }
}
