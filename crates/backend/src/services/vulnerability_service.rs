use async_trait::async_trait;
use shared::types::{Severity, VulnerabilityStatus, ID};
use std::{collections::HashMap, sync::Arc};
use tracing::{debug, info};

use crate::{
    models::Vulnerability,
    traits::{AssetRepository, VulnerabilityRepository, VulnerabilityService},
    Result,
};

pub struct VulnerabilityServiceImpl {
    repository: Arc<dyn VulnerabilityRepository>,
    asset_repository: Arc<dyn AssetRepository>,
}

impl VulnerabilityServiceImpl {
    pub fn new(
        repository: Arc<dyn VulnerabilityRepository>,
        asset_repository: Arc<dyn AssetRepository>,
    ) -> Self {
        Self {
            repository,
            asset_repository,
        }
    }

    // Helper function to calculate similarity score between two vulnerabilities
    async fn calculate_similarity_score(
        &self,
        vuln1: &Vulnerability,
        vuln2: &Vulnerability,
    ) -> f64 {
        let mut score = 0.0;

        // Base similarity on title
        if vuln1.title == vuln2.title {
            score += 2.0;
        } else if vuln1.title.contains(&vuln2.title) || vuln2.title.contains(&vuln1.title) {
            score += 1.0;
        }

        // Add score for same severity
        if vuln1.severity == vuln2.severity {
            score += 1.0;
        }

        // Add score for similar CVE
        if let (Some(cve1), Some(cve2)) = (&vuln1.cve_id, &vuln2.cve_id) {
            if cve1 == cve2 {
                score += 3.0;
            }
        }

        // Add score for similar CVSS score
        if let (Some(cvss1), Some(cvss2)) = (vuln1.cvss_score, vuln2.cvss_score) {
            if (cvss1 - cvss2).abs() < 1.0 {
                score += 1.0;
            }
        }

        // Add score for similar description if available
        if let (Some(desc1), Some(desc2)) = (&vuln1.description, &vuln2.description) {
            if desc1 == desc2 {
                score += 2.0;
            } else if desc1.contains(desc2) || desc2.contains(desc1) {
                score += 1.0;
            }
        }

        score
    }
}

#[async_trait]
impl VulnerabilityService for VulnerabilityServiceImpl {
    async fn create_vulnerability(&self, vulnerability: &Vulnerability) -> Result<Vulnerability> {
        info!("Creating new vulnerability: {}", vulnerability.title);
        let result = self.repository.create_vulnerability(vulnerability).await?;
        debug!("Vulnerability created with ID: {}", result.id);
        Ok(result)
    }

    async fn get_vulnerability(&self, id: ID) -> Result<Vulnerability> {
        debug!("Getting vulnerability with ID: {}", id);
        self.repository.get_vulnerability(id).await
    }

    async fn update_vulnerability(&self, vulnerability: &Vulnerability) -> Result<Vulnerability> {
        debug!("Updating vulnerability with ID: {}", vulnerability.id);
        self.repository.update_vulnerability(vulnerability).await
    }

    async fn delete_vulnerability(&self, id: ID) -> Result<bool> {
        info!("Deleting vulnerability with ID: {}", id);
        self.repository.delete_vulnerability(id).await
    }

    async fn list_vulnerabilities(
        &self,
        asset_id: Option<ID>,
        port_id: Option<ID>,
        severity: Option<Severity>,
        status: Option<VulnerabilityStatus>,
        limit: usize,
        offset: usize,
    ) -> Result<Vec<Vulnerability>> {
        debug!(
            "Listing vulnerabilities with filters - asset_id: {:?}, port_id: {:?}, severity: {:?}, status: {:?}, limit: {}, offset: {}",
            asset_id, port_id, severity, status, limit, offset
        );
        self.repository
            .list_vulnerabilities(asset_id, port_id, severity, status, limit, offset)
            .await
    }

    async fn count_vulnerabilities(
        &self,
        asset_id: Option<ID>,
        port_id: Option<ID>,
        severity: Option<Severity>,
        status: Option<VulnerabilityStatus>,
    ) -> Result<usize> {
        debug!(
            "Counting vulnerabilities with filters - asset_id: {:?}, port_id: {:?}, severity: {:?}, status: {:?}",
            asset_id, port_id, severity, status
        );
        self.repository
            .count_vulnerabilities(asset_id, port_id, severity, status)
            .await
    }

    async fn correlate_vulnerabilities(
        &self,
        organization_id: ID,
        min_severity: Option<Severity>,
    ) -> Result<HashMap<ID, Vec<ID>>> {
        info!(
            "Correlating vulnerabilities for organization: {}",
            organization_id
        );

        // Get assets for the organization
        let assets = self
            .asset_repository
            .list_assets(Some(organization_id), None, None, 1000, 0)
            .await?;

        if assets.is_empty() {
            debug!("No assets found for organization: {}", organization_id);
            return Ok(HashMap::new());
        }

        // Get asset IDs
        let asset_ids: Vec<ID> = assets.iter().map(|a| a.id).collect();

        // Collect all vulnerabilities for these assets
        let mut all_vulnerabilities = Vec::new();
        for asset_id in &asset_ids {
            let vulnerabilities = self
                .repository
                .list_vulnerabilities(
                    Some(*asset_id),
                    None,
                    min_severity,
                    Some(VulnerabilityStatus::Open),
                    1000,
                    0,
                )
                .await?;
            all_vulnerabilities.extend(vulnerabilities);
        }

        debug!(
            "Found {} vulnerabilities to correlate",
            all_vulnerabilities.len()
        );

        // Build correlation map based on similarity
        let mut correlation_map: HashMap<ID, Vec<ID>> = HashMap::new();
        let threshold_score = 3.0; // Minimum score to consider vulnerabilities related

        for i in 0..all_vulnerabilities.len() {
            let vuln1 = &all_vulnerabilities[i];
            let mut related = Vec::new();

            for j in 0..all_vulnerabilities.len() {
                if i == j {
                    continue;
                }

                let vuln2 = &all_vulnerabilities[j];
                let similarity_score = self.calculate_similarity_score(vuln1, vuln2).await;

                if similarity_score >= threshold_score {
                    related.push(vuln2.id);
                }
            }

            if !related.is_empty() {
                correlation_map.insert(vuln1.id, related);
            }
        }

        debug!(
            "Found correlations for {} vulnerabilities",
            correlation_map.len()
        );
        Ok(correlation_map)
    }

    async fn find_similar_vulnerabilities(
        &self,
        vulnerability_id: ID,
        limit: usize,
    ) -> Result<Vec<Vulnerability>> {
        debug!("Finding similar vulnerabilities for: {}", vulnerability_id);

        // Get the target vulnerability
        let target_vuln = self.get_vulnerability(vulnerability_id).await?;

        // Get all vulnerabilities for the same asset
        let asset_vulnerabilities = self
            .repository
            .list_vulnerabilities(Some(target_vuln.asset_id), None, None, None, 1000, 0)
            .await?;

        // Get vulnerabilities from other assets - use a reasonable limit
        let other_vulnerabilities = self
            .repository
            .list_vulnerabilities(
                None,
                None,
                Some(target_vuln.severity),
                Some(VulnerabilityStatus::Open),
                500,
                0,
            )
            .await?;

        // Combine and calculate similarity scores
        let mut scored_vulnerabilities = Vec::new();

        for vuln in asset_vulnerabilities
            .iter()
            .chain(other_vulnerabilities.iter())
        {
            // Skip the target vulnerability itself
            if vuln.id == vulnerability_id {
                continue;
            }

            let score = self.calculate_similarity_score(&target_vuln, vuln).await;
            if score > 0.0 {
                scored_vulnerabilities.push((vuln.clone(), score));
            }
        }

        // Sort by similarity score (highest first)
        scored_vulnerabilities
            .sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));

        // Take top similarities up to limit
        let similar_vulnerabilities: Vec<Vulnerability> = scored_vulnerabilities
            .into_iter()
            .take(limit)
            .map(|(vuln, _)| vuln)
            .collect();

        debug!(
            "Found {} similar vulnerabilities",
            similar_vulnerabilities.len()
        );
        Ok(similar_vulnerabilities)
    }
}
