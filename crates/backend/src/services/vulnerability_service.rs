use async_trait::async_trait;
use shared::types::{Severity, VulnerabilityStatus, ID};
use std::{collections::HashMap, sync::Arc};
use tracing::{debug, info};

use crate::{
    models::Vulnerability,
    traits::{AssetRepository, VulnerabilityRepository, VulnerabilityService},
    Result,
};

pub struct VulnerabilityServiceImpl {
    repository: Arc<dyn VulnerabilityRepository>,
    asset_repository: Arc<dyn AssetRepository>,
}

impl VulnerabilityServiceImpl {
    pub fn new(
        repository: Arc<dyn VulnerabilityRepository>,
        asset_repository: Arc<dyn AssetRepository>,
    ) -> Self {
        Self {
            repository,
            asset_repository,
        }
    }

    // Helper function to calculate similarity score between two vulnerabilities
    async fn calculate_similarity_score(
        &self,
        vuln1: &Vulnerability,
        vuln2: &Vulnerability,
    ) -> f64 {
        let mut score = 0.0;

        // Base similarity on title
        if vuln1.title == vuln2.title {
            score += 3.0; // Increased from 2.0 for exact matches
        } else if vuln1.title.contains(&vuln2.title) || vuln2.title.contains(&vuln1.title) {
            score += 1.5; // Increased from 1.0 for partial matches
        }

        // Add score for same severity
        if vuln1.severity == vuln2.severity {
            score += 1.0;
        }

        // Add score for similar CVE
        if let (Some(cve1), Some(cve2)) = (&vuln1.cve_id, &vuln2.cve_id) {
            if cve1 == cve2 {
                score += 4.0; // Increased from 3.0 as CVE match is a strong indicator
            }
        }

        // Add score for similar CVSS score
        if let (Some(cvss1), Some(cvss2)) = (vuln1.cvss_score, vuln2.cvss_score) {
            let diff = (cvss1 - cvss2).abs();
            if diff < 0.5 {
                score += 1.5; // Higher score for very close CVSS scores
            } else if diff < 1.0 {
                score += 1.0;
            } else if diff < 2.0 {
                score += 0.5; // Some similarity for scores within 2 points
            }
        }

        // Add score for similar description if available
        if let (Some(desc1), Some(desc2)) = (&vuln1.description, &vuln2.description) {
            if desc1 == desc2 {
                score += 2.5; // Increased from 2.0
            } else if desc1.contains(desc2) || desc2.contains(desc1) {
                score += 1.5; // Increased from 1.0
            } else {
                // Check for keyword overlap
                let desc1_words: Vec<&str> = desc1.split_whitespace().collect();
                let desc2_words: Vec<&str> = desc2.split_whitespace().collect();

                let common_words_count = desc1_words
                    .iter()
                    .filter(|word| desc2_words.contains(word))
                    .count();

                if common_words_count > 5 {
                    score += 1.0;
                } else if common_words_count > 2 {
                    score += 0.5;
                }
            }
        }

        // Add score for similar affected technologies
        if let (Some(tech1), Some(tech2)) = (
            vuln1.evidence.get("affected_technology"),
            vuln2.evidence.get("affected_technology"),
        ) {
            if tech1 == tech2 {
                score += 2.0;
            } else if tech1.as_str().is_some()
                && tech2.as_str().is_some()
                && (tech1.as_str().unwrap().contains(tech2.as_str().unwrap())
                    || tech2.as_str().unwrap().contains(tech1.as_str().unwrap()))
            {
                score += 1.0;
            }
        }

        // Add score for similar remediation approach
        if let (Some(rem1), Some(rem2)) = (&vuln1.remediation, &vuln2.remediation) {
            if rem1 == rem2 {
                score += 1.0;
            } else if rem1.contains(rem2) || rem2.contains(rem1) {
                score += 0.5;
            }
        }

        score
    }

    // Helper to determine if vulnerabilities are on related assets
    async fn check_asset_relationship(&self, asset_id1: ID, asset_id2: ID) -> Result<bool> {
        // Check if both assets are the same
        if asset_id1 == asset_id2 {
            return Ok(true);
        }

        // Attempt to find direct relationship between assets
        // This would typically use an asset relationship service
        // For now, we'll implement a simplified version that checks common hostname/domain
        let asset1 = match self.asset_repository.get_asset(asset_id1).await {
            Ok(asset) => asset,
            Err(_) => return Ok(false), // Asset not found, assume no relationship
        };

        let asset2 = match self.asset_repository.get_asset(asset_id2).await {
            Ok(asset) => asset,
            Err(_) => return Ok(false), // Asset not found, assume no relationship
        };

        // Check for relationship in attributes
        let is_related = match (
            asset1.attributes.get("host_info"),
            asset2.attributes.get("host_info"),
        ) {
            (Some(host_info1), Some(host_info2)) => {
                // Check if they share same IP or domain
                let ip1 = host_info1.get("ip_address").and_then(|ip| ip.as_str());
                let ip2 = host_info2.get("ip_address").and_then(|ip| ip.as_str());
                let domain1 = host_info1.get("domain").and_then(|d| d.as_str());
                let domain2 = host_info2.get("domain").and_then(|d| d.as_str());

                // Check for common IP
                if let (Some(ip1), Some(ip2)) = (ip1, ip2) {
                    if ip1 == ip2 {
                        return Ok(true);
                    }
                }

                // Check for domain/subdomain relationship
                if let (Some(d1), Some(d2)) = (domain1, domain2) {
                    if d1 == d2
                        || d1.ends_with(&format!(".{}", d2))
                        || d2.ends_with(&format!(".{}", d1))
                    {
                        return Ok(true);
                    }
                }

                false
            }
            _ => false,
        };

        Ok(is_related)
    }
}

#[async_trait]
impl VulnerabilityService for VulnerabilityServiceImpl {
    async fn create_vulnerability(&self, vulnerability: &Vulnerability) -> Result<Vulnerability> {
        info!("Creating new vulnerability: {}", vulnerability.title);
        let result = self.repository.create_vulnerability(vulnerability).await?;
        debug!("Vulnerability created with ID: {}", result.id);
        Ok(result)
    }

    async fn get_vulnerability(&self, id: ID) -> Result<Vulnerability> {
        debug!("Getting vulnerability with ID: {}", id);
        self.repository.get_vulnerability(id).await
    }

    async fn update_vulnerability(&self, vulnerability: &Vulnerability) -> Result<Vulnerability> {
        debug!("Updating vulnerability with ID: {}", vulnerability.id);
        self.repository.update_vulnerability(vulnerability).await
    }

    async fn delete_vulnerability(&self, id: ID) -> Result<bool> {
        info!("Deleting vulnerability with ID: {}", id);
        self.repository.delete_vulnerability(id).await
    }

    async fn list_vulnerabilities(
        &self,
        asset_id: Option<ID>,
        port_id: Option<ID>,
        severity: Option<Severity>,
        status: Option<VulnerabilityStatus>,
        limit: usize,
        offset: usize,
    ) -> Result<Vec<Vulnerability>> {
        debug!(
            "Listing vulnerabilities with filters - asset_id: {:?}, port_id: {:?}, severity: {:?}, status: {:?}, limit: {}, offset: {}",
            asset_id, port_id, severity, status, limit, offset
        );
        self.repository
            .list_vulnerabilities(asset_id, port_id, severity, status, limit, offset)
            .await
    }

    async fn count_vulnerabilities(
        &self,
        asset_id: Option<ID>,
        port_id: Option<ID>,
        severity: Option<Severity>,
        status: Option<VulnerabilityStatus>,
    ) -> Result<usize> {
        debug!(
            "Counting vulnerabilities with filters - asset_id: {:?}, port_id: {:?}, severity: {:?}, status: {:?}",
            asset_id, port_id, severity, status
        );
        self.repository
            .count_vulnerabilities(asset_id, port_id, severity, status)
            .await
    }

    async fn correlate_vulnerabilities(
        &self,
        organization_id: ID,
        min_severity: Option<Severity>,
    ) -> Result<HashMap<ID, Vec<ID>>> {
        info!(
            "Correlating vulnerabilities for organization: {}",
            organization_id
        );

        // Get assets for the organization
        let assets = self
            .asset_repository
            .list_assets(Some(organization_id), None, None, 1000, 0)
            .await?;

        if assets.is_empty() {
            debug!("No assets found for organization: {}", organization_id);
            return Ok(HashMap::new());
        }

        // Get asset IDs
        let asset_ids: Vec<ID> = assets.iter().map(|a| a.id).collect();

        // Collect all vulnerabilities for these assets
        let mut all_vulnerabilities = Vec::new();
        for asset_id in &asset_ids {
            let vulnerabilities = self
                .repository
                .list_vulnerabilities(
                    Some(*asset_id),
                    None,
                    min_severity,
                    Some(VulnerabilityStatus::Open),
                    1000,
                    0,
                )
                .await?;
            all_vulnerabilities.extend(vulnerabilities);
        }

        debug!(
            "Found {} vulnerabilities to correlate",
            all_vulnerabilities.len()
        );

        // Build correlation map based on similarity and asset relationships
        let mut correlation_map: HashMap<ID, Vec<ID>> = HashMap::new();
        let threshold_score = 3.0; // Minimum score to consider vulnerabilities related
        let related_assets_bonus = 1.5; // Additional score for vulnerabilities on related assets

        for (i, vuln1) in all_vulnerabilities.iter().enumerate() {
            let mut related = Vec::new();

            for (j, vuln2) in all_vulnerabilities.iter().enumerate() {
                if i == j {
                    continue;
                }

                // Calculate base similarity score
                let mut similarity_score = self.calculate_similarity_score(vuln1, vuln2).await;

                // Check if the vulnerabilities are on related assets
                let assets_related = (self
                    .check_asset_relationship(vuln1.asset_id, vuln2.asset_id)
                    .await)
                    .unwrap_or_default();

                // Add bonus score for vulnerabilities on related assets
                if assets_related {
                    similarity_score += related_assets_bonus;
                }

                // Group vulnerabilities by affected component if available
                if let (Some(comp1), Some(comp2)) = (
                    vuln1.evidence.get("affected_component"),
                    vuln2.evidence.get("affected_component"),
                ) {
                    if comp1 == comp2 {
                        similarity_score += 1.0;
                    }
                }

                // Consider vulnerabilities related if score is high enough
                if similarity_score >= threshold_score {
                    related.push((vuln2.id, similarity_score));
                }
            }

            // Sort related vulnerabilities by similarity score (descending)
            related.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));

            // Store only the IDs in the correlation map
            if !related.is_empty() {
                correlation_map.insert(vuln1.id, related.iter().map(|(id, _)| *id).collect());
            }
        }

        debug!(
            "Found correlations for {} vulnerabilities",
            correlation_map.len()
        );
        Ok(correlation_map)
    }

    async fn find_similar_vulnerabilities(
        &self,
        vulnerability_id: ID,
        limit: usize,
    ) -> Result<Vec<Vulnerability>> {
        debug!("Finding similar vulnerabilities for: {}", vulnerability_id);

        // Get the target vulnerability
        let target_vuln = self.get_vulnerability(vulnerability_id).await?;

        // Get all vulnerabilities for the same asset
        let asset_vulnerabilities = self
            .repository
            .list_vulnerabilities(Some(target_vuln.asset_id), None, None, None, 1000, 0)
            .await?;

        // Get vulnerabilities from other assets - use a reasonable limit
        let other_vulnerabilities = self
            .repository
            .list_vulnerabilities(
                None,
                None,
                Some(target_vuln.severity),
                Some(VulnerabilityStatus::Open),
                500,
                0,
            )
            .await?;

        // Combine and calculate similarity scores
        let mut scored_vulnerabilities = Vec::new();

        for vuln in asset_vulnerabilities
            .iter()
            .chain(other_vulnerabilities.iter())
        {
            // Skip the target vulnerability itself
            if vuln.id == vulnerability_id {
                continue;
            }

            let score = self.calculate_similarity_score(&target_vuln, vuln).await;
            if score > 0.0 {
                scored_vulnerabilities.push((vuln.clone(), score));
            }
        }

        // Sort by similarity score (highest first)
        scored_vulnerabilities
            .sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));

        // Take top similarities up to limit
        let similar_vulnerabilities: Vec<Vulnerability> = scored_vulnerabilities
            .into_iter()
            .take(limit)
            .map(|(vuln, _)| vuln)
            .collect();

        debug!(
            "Found {} similar vulnerabilities",
            similar_vulnerabilities.len()
        );
        Ok(similar_vulnerabilities)
    }

    async fn bulk_update_vulnerability_status(
        &self,
        vulnerability_ids: Vec<ID>,
        status: VulnerabilityStatus,
    ) -> Result<usize> {
        info!(
            "Updating status to {:?} for {} vulnerabilities",
            status,
            vulnerability_ids.len()
        );

        let mut updated_count = 0;

        for vuln_id in vulnerability_ids {
            match self.repository.get_vulnerability(vuln_id).await {
                Ok(mut vuln) => {
                    vuln.status = status;

                    // Set resolved_at if we're closing the vulnerability
                    if status != VulnerabilityStatus::Open {
                        vuln.resolved_at = Some(chrono::Utc::now());
                    } else {
                        vuln.resolved_at = None;
                    }

                    if (self.repository.update_vulnerability(&vuln).await).is_ok() {
                        updated_count += 1;
                    }
                }
                Err(e) => {
                    debug!("Failed to get vulnerability {}: {:?}", vuln_id, e);
                    // Continue with the next one
                    continue;
                }
            }
        }

        info!("Successfully updated {} vulnerabilities", updated_count);
        Ok(updated_count)
    }

    async fn get_vulnerability_statistics(
        &self,
        organization_id: ID,
    ) -> Result<std::collections::HashMap<String, usize>> {
        info!(
            "Getting vulnerability statistics for organization: {}",
            organization_id
        );

        // Get assets for the organization
        let assets = self
            .asset_repository
            .list_assets(Some(organization_id), None, None, 1000, 0)
            .await?;

        if assets.is_empty() {
            debug!("No assets found for organization: {}", organization_id);
            return Ok(std::collections::HashMap::new());
        }

        // Get asset IDs
        let asset_ids: Vec<ID> = assets.iter().map(|a| a.id).collect();

        // Statistics to collect
        let mut statistics = std::collections::HashMap::new();

        // Count by severity
        let mut severity_counts = std::collections::HashMap::new();
        severity_counts.insert("Critical".to_string(), 0);
        severity_counts.insert("High".to_string(), 0);
        severity_counts.insert("Medium".to_string(), 0);
        severity_counts.insert("Low".to_string(), 0);
        severity_counts.insert("Info".to_string(), 0);

        // Count by status
        let mut status_counts = std::collections::HashMap::new();
        status_counts.insert("Open".to_string(), 0);
        status_counts.insert("Closed".to_string(), 0);
        status_counts.insert("AcceptedRisk".to_string(), 0);
        status_counts.insert("FalsePositive".to_string(), 0);

        // Count by asset type
        let mut asset_type_counts = std::collections::HashMap::new();

        // Count recent vulnerabilities (last 30 days)
        let thirty_days_ago = chrono::Utc::now() - chrono::Duration::days(30);
        let mut recent_count = 0;

        // Process each asset's vulnerabilities
        for asset_id in &asset_ids {
            let vulnerabilities = self
                .repository
                .list_vulnerabilities(Some(*asset_id), None, None, None, 1000, 0)
                .await?;

            // Find corresponding asset to determine type
            if let Some(asset) = assets.iter().find(|a| a.id == *asset_id) {
                let asset_type_str = format!("{:?}", asset.asset_type);
                *asset_type_counts.entry(asset_type_str).or_insert(0) += vulnerabilities.len();
            }

            // Collect statistics for each vulnerability
            for vuln in &vulnerabilities {
                // Count by severity
                let severity_str = format!("{:?}", vuln.severity);
                *severity_counts.entry(severity_str).or_insert(0) += 1;

                // Count by status
                let status_str = format!("{:?}", vuln.status);
                *status_counts.entry(status_str).or_insert(0) += 1;

                // Count recent vulnerabilities
                if vuln.created_at > thirty_days_ago {
                    recent_count += 1;
                }
            }
        }

        // Add all statistics to the result map
        statistics.insert("total".to_string(), asset_ids.len());
        statistics.insert("recent".to_string(), recent_count);

        // Add severity counts
        for (severity, count) in severity_counts {
            statistics.insert(format!("severity_{}", severity.to_lowercase()), count);
        }

        // Add status counts
        for (status, count) in status_counts {
            statistics.insert(format!("status_{}", status.to_lowercase()), count);
        }

        // Add asset type counts
        for (asset_type, count) in asset_type_counts {
            statistics.insert(format!("asset_type_{}", asset_type.to_lowercase()), count);
        }

        Ok(statistics)
    }
}
